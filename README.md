  
# `The Perfect Tech-guide & Awesome-list ` ðŸ› i
### A developer's info-guide on: `tech` - `tools` - `Libs` - `Frameworks`  
<br>

- [Article is about](): `best practices` + `guide` + `awesome list` of tech-stack(libs,tools..), platforms, workflow.  
- [Multiple options](): are for you to decide based on your goals.(compare X vs Y, pros/cons, use-case..)  
- [Recommendations](): given based on summary of various factors: test or compared reviews of experts on the field.
<br>

> [*Decisions*](): have long-term impact. Dev-stack/toolchain + working method/strategy impacts your progress.  
> [*Making right choices*](): early on, increase success and progress chances, self-respecting your skills.  
> [*Nothing's perfect*, yet..]() better options/methods improves DX, workflow, structure, progress, efficiency.  
<br>

[GitHub Repo >> https://github.com/Systemic-Labs/Perfect-Stack](https://github.com/Systemic-Labs/Perfect-Stack)  

[To Contribute]() >> `add links` to items, `reason/prove` an obvious better option, `improve doc`.  
><sub>* target users - keywords: <i> `developers`, `designers`, `researchers`, `students`, `startups`, `decision makers` </i> </sub>
<br>  
  
<br>

# `Shortcuts `  

> ### [ Intro ](#starter-intro)  
> ### [ Awesome list ](#awesome-list)  
> ### [ Programming Languages ](#programming-languages)  
> ### [ Frameworks - more info/details ](#frameworks-information)  
> ### [ Extra information and discussion ](#extra-information)  

***
<br>  

## Intro  

### [`To beginners and startups`](#to-beginners-and-startups)  

First of all, don't choose software development, in hope to make money! (this advice might include any non-essential support and services jobs/products that's not actively in demand).  
With recent Ai advancement, and a over-saturated matured non-essential market, job demands are quite low, many unemployed workforce.  
Therefore:  
> Have 2nd source of income, job or support, while becoming a pro in your field.  
> You must have strong goals, motives, reasons, plans, being persistent until success.  
> You must gain high experience and achievements, be top competitive in your field.  

#### Technical Decisions

Don't make technical decisions just based on what majority follow, market hype, and main trends.., instead, decide based on multiple factors, such as:  
[Pros/Cons - Review Comparison]() - [Requirements]()- [Best fit / Integration](), 
[Problem solves]() - [Feasable / Accessible]() - [High Rated]() - [Popularity](), 
[Focus / Goals]() - [Priority / Importance]() - [Stable Eco-system]()  
and finalize your decision considering:  
- `Main Priority` - `Best fitting` - `Feasable? Can be done? (adopt / implement / execute)`  
- `Work type`: startup/job/personal - `State`: start / scale / remake / migrate / extend.  
- `Impact`: team, users, cost, deadline, dev-cycle, integration, stablity, milestone, completion.  
  
<details> <summary>..more on this topic.. >> press to expand â†´ </summary>  
  
Majority of developers adopted older popular tech/methods by the circumstances in past, by workplace/education requirements job offers, senior advice, or the 1st option encountered, or just due to common hype, in the past, but not the best choice now.  
This cycle repeats and non optimal tech get stuck in social, market, and job/edu systems, then if you adopt it, by the time you build your work on it, the tech might be near end of life, or bad/slow pace, as it holds to legacy patterns, and compatibility patches to make it work with ongoing needs of the users.  

Therefore instead of market hype, make decisions based on facts, use whatever is best for the job, mostly if you're doing your own business or planning a `startup`, deciding better tech/methods, results in productivity, efficiency and saves time/cost.  

Therefore If you're not forced or bound by a legacy eco-system or specific rules/conditions, do your research, compare options, and make decisions you benefit.  
[*..extra pointers on this topic..>>*](#new-developer-or-decision-maker)  
</details>  
.  
`Wish you good luck!`  

 ***

<br>

## Target Platforms  

[Native SDK]() `Android, iOS, embeded runtimes.. if targeting specific device abilities or inclusive native functions of an embeded device, phones or a VR headset.`

[Web]() `if the development target is general, multi-platform, web/communication based, and not limited by vendor lock-in, then use the web platform, which has most use cases, most open and is cross-platform. It covers all platforms client, server, browser, mobile devices, cloud and desktop.`
  
[System]() `in case lower level control/privacy/system access is required, or direct Hardware/OS access and high performance at scale, then a server/workstation system/s plus a custom software stack (low/mid level programming languages, SDK, runtimes..) is more suitable.`

[Cloud]() `A complete or custom system solution on web/network. You subscribe to a managed virtual system, in different levels from VPS, API, Host.. much features, managed/maintained. All pros, only cons: no physical control/access/privacy(unless self hosted)`  
  
### `Learning tips`
- Being a Dev is not easy, takes time, effort, practice and experience to gain practical skills, much to cover.  
- 1st learn the basics including the new updates. Ex:  for web >> Basics and new additions of JS, HTML, CSS.  
- Learn the main skill from Docs, or best resources, search for recent materials with high views/stats on youtube.  
- Group work, join friends, divide tasks/learning, share your findouts, practice as a team, is too much for one person.  
  
`More info: beginner guideline details` -> [Web-Dev guideline](#web-development-guideline)  

***

<br>  
<br>  

# Awesome list

***

<br>

## [AI](#ai)

### General  
[Prompt/Cloud](): `Deepseek` - `ChatGPT` - `Gemini` - `Groq`  
[Prompt/Local](): `native device` - `chat with RTX` - `Jan` - `Ollama`  
[Platform / API](): `Nvidia NIM`, `Claude`, `OpenAI`, `Google`, `x.ai`  
[Inference Providers](): `HF` - `Fireworks` - `Together.Ai` - `Replicate` - `OctoAI`  
[Browser/Runtime (client/local)]():  `Ollama` - `Web LLM` - `Web-AI` - `MLC-LLM` - `Jan/Nitro`  
[Docs-Info-Research](https://github.com/codefuse-ai/Awesome-Code-LLM) codefuse-ai/Awesome-Code-LLM  
[AI Strategy Model HL](): `Local First` `prepare process` `intent tunning` `Specialized Agents` > `Orchestration` > `Solution` > `Story/Mission follow-up`  
[AI Strategy Process ML](): `Re-iterate pipelines` > `deductive/inductive/integrate process` > `Build logical-conceptual solution stucture model` > `intent elements & rank` > `Result`  
[AI Strategy Process LL](): `in-context learning` > `fine-tuning EiF` > `Map categories` > `Rag cycle` > `output pipelines` > `update/unify/integrate/testing` > `Output`  

<br>

### LLM - AI models
[Top Rank](): `DeepSeek-R1`, `Gemini-2.x/exp`, `GPT-ox`, `Claude-3.x-Opus`  
[Full Opensource](): `DeepSeek-V3/R1` -- `Phi4` -- `Mixtral MoE`  
[Local Run](): Desktop: `Qwen2.5-Inst(md)` `Phi-4(md)` Server: `DeepSeek-R1`  
[Local Run](): Mobile: `Phi-4(sm)` `Qwen2.x-(sm)` `SmolVLM`  
[Vision/VLM](): `PaliGemma` `SmolVLM` - (visual & text LLM)  

### Dev Environments
[Hybrid Local](): VS-Code + `Github Copilot` - Pros: `Free` + `Local` + `Cloud`  
[Cloud Environment](): `Gitpod` - `stackblitz` - dev > build > deploy/container/integration  
[AI Hybrid IDE](): Cursor: `extras` - `better results` -- Windsurf: `Simpler defaults`  

<sub> * `AGI`(Artificial General Intelligence) -- `MoE`(Mixture of Experts) </sub>  
<br>

### AI Tools, Audio, Video  

[Autonomous Agents](): long-term mem: `MemGPT` - `CrewAI` -- toolchain: `Langchain` - `AutoGPT`  
[Science/Research](): `NotebookLM (Gemini 2.x exp)` + Specific tools/models/libs  
[Audio LL](): text to music: `Udio`  
[Audio TTS](): `LLASA TTS` - `Parler TTS` - `PlayHT`  
[Audio HL](): `Replika` - `ElevenLabs` -- speech to text: `Deepgram`  
[Image Dev/API](): `DALL-E`, `Stable Diffusion`, `Imagen`  
[Image - User/App](): `MidJourney`, `FreePik`, `Adobe Firefly`  
[Physics Engine](): `Genesis` -- [Image to 3D world](): `Odyssey `  
[Video creation](): `Veo2` - `Kling-v1.6` - `Sora` - `Mochi(local)`  
[Visual input](): `Grok vision` - `Amazon Rekognition` - `Imagen`  
[Code assist](): `AI IDEs` - `Github Copilot` - `Ollama` + `Qwen2.x LLM`  
[Dev assist](): `ready-made Agents workflow` - `Open Devin` - `Devika`  
[Dev Tools](): Local Hub: `Ollama UI` `LM-studio` `Jan` - interact with websites: `GPT Crawler`  

<br>

### Best youtube AI Channels - <sub> *`links open's Youtube channel`* </sub>  
`Concept` -- [bycloud](https://www.youtube.com/@bycloudAI)  
`Tutorial/Practical` -- [Ai Jason](https://www.youtube.com/@AIJasonZ/videos)  
`News/Info/General` -- [Matthew Berman](https://www.youtube.com/@matthew_berman/featured)  
`Research/Science` -- [Code your own AI](https://www.youtube.com/@code4AI/videos)
<br>

##### `About ` [Different AI generations](#about-ai---generations) >>  
##### *[AI Awesome list Gist - more info/tools/applications](https://gist.github.com/Peyman-Borhani/57c3dd9ec0754c68d1dda3698b00f760)* >>  (Archived/Out-dated)

[_^_](#shortcuts-)

***
<br>

## [Frameworks](#frameworks--) >>  

 - **`Mobile`**: [Web based:]() (multi-platform) Tauri, Socket - Capacitor [Native:]() device SDK(only if required)  
 - **`Desktop`**:  Tauri (Web App),  Deno executable(Web/CLI).  
 - **`Front-end`**: Svelte(best overall, best DX) - Vue(past populary, jobs) - Solid(React replacement).  
 - **`Back-end`**: JS runtime-> Deno, Node.js/Bun - or specific platform, services, programming languages..  
 - **`Full-stack`**: Svelte-kit (true fullstack) - Astro(many frameworks) - Next/Nuxt (popular backends)  
 - **`Crossplatform`**: Tauri(desktop, mobile, Rust functions) - Socket runtime (desktop, mobile, P2P data)  
 - **`Programming Languages`**:  JS, Zig, Rust, Go, Elixir, Mojo, all based on use-case: client/server, AI, Mobile. [..more >>](#programming-languages)

[_^_](#shortcuts-)  
<br>  

### [UI](#ui-) >>  
**`Standard CSS`**:

 - when more control, precision and customization or zero dependency is required.
 - Big-picture of system design is clear to a CSS specialist, just by looking at the code.  
 - new CSS standards solve much issuess developers had in the past.  
 - recommended for: highly custom UIs, advanced projects,
 - in any case you must master it to be able to effectively design or use other libs.  
 
 **`UI Lib / Kit `** - *main advantages* >>  
 - reduced text instructions (+readability)  
 - more uniform design model in teams. (mostly for junior devs)  
 - faster development and prototyping.  (mostly on abstract components)  
 - tooling automation, pre/post processing..  
 
### [UI categories](#ui-categories)

- **`CSS utility frameworks`**
  -`UnoCSS`: use presets of tailwind, DaisyUI, etc.. it compiles to to standard CSS.  
  -`Lightening CSS`: tool for short codes, presets, functions, optimizing, speed, minifier.  
- **`Headless/Structure`** (you do custom style): headless ui, Melt UI, Bits UI (Svelte)
- **`Tailwind`**: short-code classes, has pro/cons, yet from v3.4 is good to use in right way.  
- **`Minimal Libs`**: Melt UI(basics), Pico CSS(default styles), BeerCSS, DaisyUI(pure CSS lib)  
- **`CSS toolkit`**:  Tailwind or UnoCSS - build available CSS presets/syntax into standard CSS  
- **`UI-Kits`**: CSS components: `Daisy UI` - functional components: `Skeleton`, `flowbite`, `ShadCN`  
- **`Icon-sets`**: `unplugin-icons`: best to import various icons, no deps, vite plugin tooling  
- **`Fonts`**: `System font` `Roboto` `Segoe-UI` `Lucida` `Oswald` `Slabo` `Commit-Mono`  
- **`3D`**:  Spline, Babylone.js(FW), Three.js(lib), Threlte(Svelte+three), Unity Tiny  
  
### [UI Recommendations](#ui-recommendations--reason) + `reason`:  

 - `UnoCSS`  - best toolkit and  presets. (code in other Lib, compiled into standard CSS)  
 - `picoCSS` - best for predefined styling of standard HTML Tags.  
 - `DaisyUI` - best pure CSS UI components lib you can get while JS is optional.  
 - `BeerCSS` - better option in case you're into material design concept.
 - `Shadcn`  - best customizable components kit (mostly in Shadcn-Svelte).
 - `Skeleton UI`- best UI components kit for Svelte framework.
 - `Agnostic UI`- various pros, in case it benefit your work.  

[_^_](#shortcuts-)  
<br>  

### [Cloud platforms](#cloud-platforms):  

- `Cloudflare`: most professional option, reliable, advanced network system and services.  
- `Hosting clouds`: used to host site/app, but now offer many cloud functions/solutions Ex: Vercel or Netlify  
- `Enterprise`: (more features+scale - extra cloud functions/services)  
  1. Amazon AWS -- 2. Azure (Microsoft) -- 3. Google/Firebase  

#### [`Alternatives`](#alternatives): 
- `Cloud`: Vercel, Supabase - `CMS`: Prismic, Builder.io  
- `Self-host`: [Cloud](): Coolify - [CMS](): Sveltia - [Server](): `PocketBase`  
- `Decentralised` -> Nostr, Bluesky/AT protocol. Social features, free, secure, anti-censorship.  
- `Self hosted lib`: Gun.js => free, encrypted, distributed (web torrent)  
- `Fullstack servers` + `default options`: cyclic.sh(full options +S3 +DynamoDB) - railway.app (+postgreSQL)  

[_^_](#shortcuts-)  
<br>

### [Database](#database):  

- `Next-Gen`: (decentralized/p2p privacy, security, extras): Nostr, AT protocol, GunDB.  
- `Performance`: cloud edge DBs `->` Turso(libSQL), Cloudflare/DenoDeploy(KV). `multi-model`: Redis + modules.  
- `Innovative`: Drizzle + Turso - EdgeDB - SurrealDB - Dgraph(graphQL+DX)  - Vector DBs (AI use-cases).  
- `Open Source`:  
  - `libSQL`: a fork of SQLite but both local, remote and server.  
  - `Arango DB` (multi-model) to self host or cloud.  

- `Recommendations`:  

  > **` Nostr`** : decentralized communication protocol. user ownership of data, privacy and sharing.  
  > **` Turso`** : libSQL DB on cloud/edge. (fastest SQL on edge)  
  > **` libSQL`** : best SQLite fork for local DB (server/mobile app)  
  > **` Drizzle`**: ORM worth using, **`Reason`**: work with various DB formats without knowing them.  
  > **` EdgeDB`**: simple + you prefer: EdgeQL + native ORM/graphQL-ish model (no need seperate ORM).  
  > **` SurrealDB`**: advanced, lots of DB models, features, customize and options.

[_^_](#shortcuts-)  

<br>  

### [API / Communication patterns](#api):  


- `REST `: a client request data/information.. from a server, which responds with state+data.  
- `GraphQL`. similar to rest but query a specific set of data, by relation/s, only effective if correctly queried(not less, not more).  
- `gRPC / tRPC` . binary data, prioritise performance, volume, and security. next generation of protobuffers.  
- `WebSocket` For real time, low latency applications.  
- `WebRTC / WebTorrent`  applications of distributed net, shared, p2p, serverless, save cost, user privacy/annonymity.  
- `ORM (DB interaction model)` custom SQL/nonSQL query access method. custom relational behavior, code to DB interfacing.  
<br>
  
## [Programming Languages](#programming-languages)  

### Low level  
- **`Rust`**: WebASM std / Safe / Precise / System / Performance / Resources / Community.  
- **`Zig`** - **`Carbon`**: C++ alternatives - **`Julia`**: low-level Performance, high-level syntax.  
- **`Go`**: (Low/Med level): simple good syntax, well developed/maturity, good for backend.  
- **`Nim`**(+fast, semi python syntax). **`Mojo`**: (+python-like, resources, AI, Devs like it).  
    
### High level
- **platform based**: `All: Web/JS`, `AI: Python, JS (APIs)`, `Mac/IOS: Swift`.  
- **other good langs**: `Elixir`, `Haskel`, `C++`, `C#`, `Bend`.  
- **`Bend`**: Parallel processing computation. Use CPU/GPU cores **WITHOUT** specific/low-level methods (Cuda, Metal..)
  
### Type Safety
[Typescript](): Not a language, a superset over JS - a type system for JS - compiles to JS.  
[Valibot](): schema library for validating structural data. also on runtime and integration point.  
`..note`: type safety feature is effective in specific scenarios/points, and is not required in general.  

<details> <summary> `..more on type safety and typescript`: </summary> Majority misunderstand TS for safety, security and a language by itself, while it mostly impacts development cycle. In production is only effective if implemented for runtime on integration validation points. Therefore use Typescript/typesafety layer only when the usecase is valid, or required. such as IO, restricted or custom defined data structures. `Ex`: database schemas, configuration, components I/O authentication..  
`Practical usage`: In large teams - random/outsourced/careless developers drop into codebase.  
When type restrictions is forced on developers, they pre-encounter potential issues/errors, before conflict is reached, which forces them to solve it and follow type integrity on code import/export, and prevent careless mistakes (in algorithms, process..) before delivering their work. This ensures all follow same guidelines and defined boundries to get expected results even if they don't access/visualize/understand the code structure and intentions.  
The Cons: Only runs at dev time, removed in production. A solo dev or small team owning codebase won't need it, unless proven otherwise or on integration and run-time.  a codebase becomes more complex to read/visualize.. Only good TS devs/teamlead can understand or reason the usage, for others is just a complexity addon.  

Therefore it cost more time, resources and efficiency. It's simpler and more efficient to use a validation system such as `Valibot`, at integration, critical or specific points, it works in JS too, and in runtime.  
</details>
  
[_^_](#shortcuts-)  
<br>
  
### [Other stuff]()  
- **`Hosting`**: .. Vercel, Cloudflare Pages, Deno Deploy, Begin, Netlify.  
- **`Store/e-commerce`**: free open-source, best for developers: `Medusa` . best for non-devs: `Shopify`.  
- **`Static Site Generator`**:  Astro(all), Hugo(go), Hexo(js), Next(react), Nuxt(vue), MkDocs(py)  
- **`Content Management System`**:  Primo(svelte), Strapi, Ghost, Netlify CMS, Apostrophe, Factor(vue).
- **`Audio API`**: Tone.JS(free, all round audio API),  Twilio(Call communication, speech).  
- **`Dev/Repo` Platforms**: Github, Gitlab, Gitea (self-host), Stackblitz, Notion, Collab..  
- **`Dev tools`**:  CLI tools(GIT, bash, pnpm), vite(bundler), vs-code + extensions, emmet..
- **`Kubernetes`**: Fault Taulerant application containers to manage scale, monitor, resources.
- **Photo/Image**: format -> `Avif`, compress/encode-> `Avif encoder (best from: AOM, lovell, rav1)`  
  - Libs: `Sharp`, `lib-vips`, `lib-heif`, `ImageMagic (good as online tool/ or cloud usage..)`  

[_^_](#shortcuts-)  
***
<br>  
  
<br>  

## [Frameworks information](#frameworks-information)  

<br>  

### [Frameworks Architecture](#frameworks-architecture)  

- `Front-end`(client side) - `Backend`(server-side) - `Fullstack`(Front and back) - `Unified Fullstack`(integrated model).  
- **SSG** `Static Site Generation` pre-built app/content > host-CDN > page/app delivered on user request > on client side.  
- **CSR** `Client side rendering` both static and dynamic content on client side. Updates are based on app logic and UI design.  
- **SSR** `Server Side Rendering` UI > client > user interaction > server > processed real-time on server > new renders > client.  
- **Modern** `Custom Multi Model` SSG + SSR + custom optimizations, only changes updates/delivers. `+performance` `+efficiency`.  
- various features: `Reactivity` - `Signals` - `Runtime` - `Compiled` - `Snippets` - `defined structure` - `Event management`.  

### [Frontend](#frontend):  
 - **1. `Svelte`**: (Best overall), DX+, innovative, compiles to standard web, long term strategic choice.  
 - **2. `Solid`**: (Minimal) fast, efficient, reliable, fine tuned reactivity, react devs alternative.  
 - **3. `Vue`**: (community) __ `Angular` / `React` / `.Net` (GG/FB/MS company platforms), Job offers/forced/required.  
<br>  

### [Backend](#backend):

#### JavaScript Runtimes:  
  - **`Deno`**: secure by default, lighter, faster, Wasm, better concept, +DX. *(recommended)*  
  - **`Node`**: core JS Runtime most libs, support, popular. Node.JS BE frameworks: `hono`, `polka`, `koa`  
  - **`Bun`** : Node.js compatible but higher performance.  

#### Python eco-system:  jobs, popularity, AI libs/community, resources, ease of usage, +beginners.  

[_^_](#shortcuts-)  
<br>  

### [Fullstack](#fullstack): 
**`Sveltekit`**: complete yet custom scalable solution, flexible use of frontend + backend.  
> *Best web/app framework + DX, combined best practices and innovations in web ecosystem.*  
**`Phoenix`**: Live view generative FE + Elixir BE. Best for server oriented web development.  
**`Astro`**: your frontend of choice + a unified good set of predefined patterns, tools, DB!  
**`Custom Build`**: `Vite(bundler/dev-server)` + `Nitro(Server)` + `Vinxi(Router)` + `FE UI/interface`  

**`Node.js cloudish frameworks`**:  Next(Vercel/React), Nuxt(VUE), Astro(multi platform).  
<br>  

### [Svelte framework pros](#svelte-framework-pros):  
**`Developer Experience`**: write less code, concentrate on your ideas, not development complexity.  
**`Standard`**: the code is compiled to standard JS. Fast/optimized, can be used anywhere, reusable.  
**`Less complexity`**: easier to read code, compiled, no v-dom overhead, no framework caused issues at runtime.  
> less Testing/Dependency issues:  unexpected reactions, conflicts, misunderstanding source of issues.  
> less Errors: due to not having runtime dependencies, or external factors except your own code.  

**`Less Cost`**: easier to read code of other devs => continue their work + less bugs + less testing + faster development.  
**`Smaller bundle size`** (Compiled), without virtual-dom and framework overhead...  

[_^_](#shortcuts-)  
***
<br>  


# [Extra Information](#extra-information)  
<br>  

## **Web Development - about definitions**   
- `Front-end`: Dev/Design of client side web app/site, dev/Design. HTML5, CSS, JavaScript, PWA, frameworks, Web assembly..  
- `Back-end`: processing/data on server network, host/cloud, centralized or distributed. SSR(Server Side Rendering). 
- `DevOps`: manage and process dev/product ecosystem. analytics, control, automation on Local, remote, distributed systems  
- `Cloud`: online server platforms, you can subscribe to services: process, storage, resources, ready made functions.  
- `Cloud services`:  when you don't have a scalable server/resources. 2- require API/Apps/services from amazon, google..  
- `Developer Experience`: (DX) satisfaction rate of developer, plus how empowering, practical, direct, and unambiguous it be.  
- `Correct development method` â‡’ simplify, reuse, secure, update, avoid complex dependencies/overhead.  
- `Software Engineering`:  use engineering principles and process-methods to approach the issue/task.  
- `Solution Architect`: a senior lead/engineer that evalutes an idea/goal/issue, then design, document and execute a structured plan while making many considerations.  
> A solution architect has some business insight/strategy and various technical knowledge/experience, using engineering principles, analytics.. design-pattern-process-methodology and some research experience.  

[_^_](#shortcuts-)  
  
***

## **[Web development guideline](web-development-guideline):**  
 **1. Learn the base web standards** -> (HTML, CSS, Javascript) follow/practice tutorials. Make few apps.(ex: Todo)  
 **2. New web dev** -> latest updates in JS/ES, HTML, CSS  practice well.  
 **3. Update previous apps you made**, using new things you learned. make a game and a blog site.  
 **4. Deploy**: learn how to host/deploy your site.  Host on cloudflare pages, deno deploy, begin, netlify, github pages,...  
 **5. Learning decision**: learn extra stuff once is required(predict it). (Ex: DB, AI, specific tools/libs...)  
 **6. Learn a Framework**: better Dev-eXp & scoping. composable, reusable components, structure and configuration.  
 **7. Learn Design**: Patterns, tools, UI/UX(user interface/experience). Concepts: visual clarity, visual effects, utility 1st.  
 **8. Responsive design**: native looks, any device, clear focus, usability/accessibility. CSS flex, grid...  
 **9. Backend**: 1. Sveltekit(if using svelte) ___ 2. Deno: new js-runtime replacement for Node.js by its creator.  
 **10.Personal** various experiences, use GIT, github, Make a portfolio site (show case). a social profile: Linkedin + twitter.  
 **11.Testing/Typing**: only if neccessary and: in large teams on complex projects with security risk or much new/junior/outsourced devs.  
 **12.Summary**: Be an expert in one field, pro on few more, know about the rest. Fullstack: Frontend + Backend + Eco-system + Experience.  

[_^_](#shortcuts-)  


## **[About AI - Generations](about-ai---generations)**

`Past AI`: Machine Learning + Data/algorithms.  
Output results such as detection/decision/states... are made from a defined input processed by Machine Learning + Data science tools/patterns to extract meaningful data/states, using specific algorithms and models.  

`Pre/Current`: Generative AI, builds result from input data.  
- input can befrom single or multiple sources such as: files/DB/web/user prompt/system/parameters...  
- input/User describes a composed request: question/s, problem/s, statement prompt/s, data.  
- then Ai model process all to construct/expand/difuse/compose/conclude... Finally it generates the result based on request/objective.  

`Present`: Generative AGI. Is the same as above, but more accurate, matured and efficient.
- multi-modal, multi-tooling, larger models, improved data quality and training, higher performance hardware.  
- various methods and techniques used to improve results.
- increase precision/performance, reduce hallucination/mistakes, iterative pipelines to improve/abstract/clean/test data, verify, validate results.  

`Future Ai`: is a systemic AGI.  It creates custom composed advanced solutions, adding real-time autonomuos abilities.  
The past generation recognise, detect, compose a result, This new generation understands (input + general concept + you).  
- focused concepts and Results processed in realtime cycle, by a general purpose dynamic multi-model.  
- the output iterates/evolves based on all defined parameters, whatever interacts with it.  
- time-scalable, includes a history record, remember and relates, process past and current events, consider future.  
- optional autonomous act: triggers new events or impact external entities, based on various factors/parameters + input/sensor data.

[_^_](#shortcuts-)


 ### [Work Tips](#work-tips):
 - Better: learn best new tech options, practice, freelance, get hired, build an idea startup team.
 - Easier: take a positive internship, learn, collab, you either get hired or improve portfolio/experience.  
 - Collaborate: Learn/Use collaboration tools/platforms like GitHub.  
 - Job: find a job or startup a new team.  Wish you the best.  

*** 
<br>  

## [The Web - status summary](#the-web-status-summary)
The web was originally made to communicate with text and data, it later evolved to present simple graphics and images.  
<details> <summary>...press to expand. </summary>  
Hardware advancements in performance and capacity, plus emerging smartphones and social networks caused web based online services go mainstream in network communications, it progressed fast and competes with native platforms.  
The sudden progress pace in contrast with the concept of keeping it backward compatible with legacy standards, caused some complexity and confusion in the last decade due to workarounds to support new features by vendor prefixes, various 3rd party libs, tools and frameworks to achieve demands of dev/user/market. The slow adoption of new trends was caused by issues with backward compatibility of existing sites and old systems while native mobile and desktop platforms had all breaking changes at once to support new hardware. By then 3rd party libs, prefixes and frameworks... were made to solve/patch the issue and provide features that didn't exist in web standards yet.  

Good news, the new web standards and innovations, improved the situation, furthermore Frameworks evolved and matured including new Web APIs to provide functionality and access to new technologies. Therefore with much flexibility, compatibility and openness, Web eco-system can now compete with native desktop and mobile platforms.  

Whenever learning something, learn latest stable standards and best practices, some of the old prefixes, 3rd party libs,... are not required anymore...(as explained above) unless is justified, mandatory or no alternatives. The recommended trends mentioned here were handpicked by checking reviews comparison, personal experiments, and by looking into new trends top professionals adopt.  
</details>

[_^_](#shortcuts-)  
***
<br>  

### [New developer or decision maker?](#new-developer-or-decision-make?)
<details>
<summary> ...Details - Reasons and Pointers on choosing tech stack/methods... (press to expand)  
</summary>
Avoid learning 6 ~ 10+ years old stuff if a better alternative is available.
old tech was made for past era ecosystem, development model and HW/SW/issues.  

Is still popular due to seniors who learned it in past when it was a valid option and using it at work for years, later new developers are forced to follow them. This process might repeat multiple times..  

The old popular tech nature: it works, is popular and has big community and resources, yet in time it becomes more complex, due to extensions, compatibility patches and conflict solving layers to make both the original and new syntax/tools/requirements work together...  Aside of that each time a new feature is added, this process might repeat, and the platform gets large, complex, multiple different revisions.(Ex: MS SDKs, .net framework..)  

Breaking changes and migration: when a new feature that contradicts something in the system which can't be solved, the devs will decide to either give up on the feature, add extra flags/configs or make a breaking change, thus you must stay on old branch or learn + update your previous codes or totally migrate if is hopeless.  
Each time a breaking change shows up, you might need to repeat this process. this makes multiple dev branches in a company if the team can't / won't follow.  

Prevent Issues:  an old legacy target which depends on layers of other legacy tech, will encounter conflicts, compatibility, deprecated dependencies, which will cost time + resources + man power to solve them.  
Low level coding is not affected much by the mentioned issues. they rarely change, and if so, is about new features, compatibility and stability.  

Unnessecary overhead: as old devs retire,  new ones might add extra layers of abstraction instead of updating the original code, these issues cause: extra complexity, overhead, extra cost in long-term, Large number/size of files, large developer teams, or slow working pace,...
</details>

[_^_](#shortcuts-)  
***
<br>  
