<script type="module">
  const MD = `
    
# `The Perfect Tech-guide & Awesome-list ` ðŸ› i
### A developer's info-guide on: `tech` - `tools` - `Libs` - `Frameworks`  
<br>

- [Article is about](): `best practices` + `guide` + `awesome list` of tech-stack(libs,tools...), platforms, workflow.  
- [Multiple options](): are for you to decide based on your goals.(compare X vs Y, pros/cons, use-case..)  
- [Recommendations](): given based on summary of various factors: test or compared reviews of experts on the field.
<br>

> [*Decisions*](): have long-term impact. Dev-stack/toolchain + working method/strategy impacts your progress.  
> [*Making right choices*](): early on, increase success and progress chances, self-respecting your skills.  
> [*Nothing's perfect*, yet...]() better options/methods improves DX, workflow, structure, progress, efficiency.  
<br>

[To Contribute]() >> `add links` to items, `reason/prove` an obvious better option, `improve doc`.  
><sub>* target users - keywords: <i> `developers`, `designers`, `researchers`, `students`, `startups`, `decision makers` </i> </sub>
<br> 

  
# `Shortcuts `  

>  ### [ Starter intro ](#starter-intro)  
>  ### [ Awesome list ](#awesome-list)  
>  ### [ Programming Languages ](#programming-languages)  
>  ### [ Frameworks - more info/details ](#frameworks-information)  
>  ### [ Extra information and discussion ](#extra-information)  

***
<br>  

##  Starter intro  

### [`To beginners and startups`](#to-beginners-and-startups)  

> Don't make technical decisions just based on what others do, market hype, popular trends...  
...instead, decide based on multiple factors, such as:

[Pros/Cons - Review Comparison]() - [Requirements]()- [Best fit / Integration](),  
[Problem solves]() - [Feasable / Accessible]() - [High Rated]() - [Popularity](),  
[Focus / Goals]() - [Priority / Importance]() - [Stable Eco-system]()  
and finalize your decision considering: 
- `Main Priority` - `Best fitting` - `Feasable? Can be done? (adopt / implement / execute)`  
- `Work type`: startup/job/personal - `State`: start / scale / remake / migrate / available.  
- `Impact`: team, users, cost, dev-cycle, integration, stablity, milestone, completion.  
  
<details> <summary>...Why? >> press to expand this topic â†´ </summary>  
  
Majority of developers adopted older popular tech/methods by the circumstances in past, by workplace/education requirements job offers, senior advice, or the 1st option encountered, or just due to common hype, in the past, but not the best choice now.  
This cycle repeats and non optimal tech get stuck in social, market, and job/edu systems, then if you adopt it, by the time you build your work on it, the tech might be near end of life, or bad/slow pace, as it holds to legacy patterns, and compatibility patches to make it work with ongoing needs of the users.  

Therefore instead of market hype, make decisions based on facts, use whatever is best for the job, mostly if you're doing your own business or planning a `startup`, deciding better tech/methods, results in productivity, efficiency and saves time/cost.  

Therefore If you're not forced or bound by a legacy eco-system or specific rules/conditions, do your research, compare options, and make decisions you benefit.  
[*...extra pointers on this topic...>>*](#new-developer-or-decision-maker)  
</details>  

` Wish you good luck! `  
 ***
<br>

## Target Platforms  

[Native SDK]() `Android, iOS, embeded runtimes... if targeting specific device abilities or inclusive native functions of an embeded device, phones or a VR headset.`

[Web]() `if the development target is general, multi-platform, web/communication based, and not limited by vendor lock-in, then use the web platform, which has most use cases, most open and is cross-platform. It covers all platforms client, server, browser, mobile devices, cloud and desktop.`
  
[System]() `in case lower level control/privacy/system access is required, or direct Hardware/OS access and high performance at scale, then a server/workstation system/s plus a custom software stack (low/mid level programming languages, SDK, runtimes...) is more suitable.`

[Cloud]() `A complete or custom system solution on web/network. You subscribe to a managed virtual system, in different levels from VPS, API, Host... much features, managed/maintained. All pros, only cons: no physical control/access/privacy(unless self hosted)`  
  
### `Learning tips`
- Being a Dev is not easy, takes time, effort, practice and experience to gain practical skills, much to cover.  
- 1st learn the basics including the new updates. Ex:  for web >> Basics and new additions of JS, HTML, CSS.  
- Learn the main skill from Docs, or best resources, search for recent materials with high views/stats on youtube.  
- Group work, join friends, divide tasks/learning, share your findouts, practice as a team, is too much for one person.  
  
> ` Go to beginner guideline details `-> [Web-Dev guideline](#web-development-guideline)  
***
<br>  

# Awesome list  
<br>

## [AI](#ai)

### General  
- [Chat/Prompt](): Online: `Groq` - `ChatGPT` - Local: `chat with RTX` - `Jan`.  
- [Platform / API](): `Nvidia NIM`, `OpenAI`, `Clarifi(various)`, `Google`, `Microsoft`, `x.ai`.  
- [Browser/Runtime (client/local)]():  `Web LLM` _ `Web-AI` _ `MLC-LLM` _ `Jan/Nitro`
- [AI Strategy](): `first local`, `Specific`, `in-context learning > fine-tuning EiF to usecase > RAG`  
<br>

### AGI - LLM models
- [Top Ranked]():  `Claude-3-Opus`, `GPT4-o-next`, `Grok`, `Llama-3-400B+ instruct`.  
- [Opensource](): `Phi3` _ `Mixtral MoE` _ `Command R+` _ `DBRX`.  
- [Run Locally](): Mobile: `Phi3-mini-3.8B` _ Desktop: `Phi-3-small` - `Llama-3-8B instruct`.
- [Vision/LM](): `PaliGemma` combined visual+text LLM + can fine-tune well for specific use-case.  

<sub> * `AGI`(Artificial General Intelligence) .... `MoE`(Mixture of Experts) </sub>  
<br>

### Tools, Audio, Video...
- [Autonomous Agents]() _ `long-term mem`: [MemGPT]() - [CrewAI]() _ `+toolchain`: [Langchain]() - `AutoGPT`  
- [Audio](): `Udio` text to music _ `PlayHT` or `ElevenLabs` text to speach _ `Deepgram ` speech to text  
- [Image](): `DALL-E`, `Stable Diffusion`, `Imagen` - APP-(user): `MidJourney`, `FreePik`, `Adobe Firefly`  
- [Visual input](): `Grok vision` - [Video creation](): `Sora ` most realistic videos bythe mean time.
- [Code assist](): `Github Copilot` - `GPT-4 Chat/API` - [open-source](): `Open Devin` - `Devika`.
- [Dev Assist](): - Local AI Hub: `Ollama UI` `LM-studio` `Jan` - interact with a website: `GPT Crawler`  
<br>

Best youtube AI Channels:  [bycloud](https://www.youtube.com/@bycloudAI) - [Ai Jason](https://www.youtube.com/@AIJasonZ/videos) - [Matthew Berman](https://www.youtube.com/@matthew_berman/featured) 
<br>  

##### `About ` [Different AI generations](#about-ai---generations) >>  
##### *[Check AI Awesome list for more AI info/tools/applications, more details.](https://gist.github.com/Peyman-Borhani/57c3dd9ec0754c68d1dda3698b00f760)* >>  

[_^_](#shortcuts-)

---
<br>

## [Frameworks](#frameworks--)  >>
 - **`Mobile`**: [Web based:]() (multi-platform) Tauri, Socket - Capacitor [Native:]() device SDK(only if required)  
 - **`Desktop`**:  Tauri (Web App),  Deno executable(Web/CLI).  
 - **`Front-end`**: Svelte(best overall, best DX) - Vue(past populary, jobs) - Solid(React replacement).  
 - **`Back-end`**: JS runtime-> Deno, Node.js/Bun - or specific platform, services, programming languages...  
 - **`Full-stack`**: Svelte-kit (true fullstack) - Astro(many frameworks) - Next/Nuxt (popular backends)  
 - **`Crossplatform`**: Tauri(desktop, mobile, Rust functions) - Socket runtime (desktop, mobile, P2P data)  
 - **`Programming Languages`**:  JS, Zig, Rust, Go, Elixir, Mojo, all based on use-case: client/server, AI, Mobile. [(..more)>>]()

[_^_](#shortcuts-)  
<br>  

### [UI](#ui-) >>  
**`Standard CSS`**:
>
 - when more control, precision and customization or zero dependency is required.
 - Big-picture of system design is clear to a CSS specialist, just by looking at the code.  
 - new CSS standards solve much issuess developers had in the past.  
 - recommended for: highly custom UIs, advanced projects,
 - in any case you must master it to be able to effectively design or use other libs.  
 
 **`UI Lib/kit `** - *main advantages* >>  
 - reduced text instructions (+readability)  
 - more uniform design model in teams. (mostly for junior devs)  
 - faster development and prototyping.  (mostly on abstract components)  
 - tooling automation, pre/post processing...  
 
 ### [UI categories](#ui-categories)
 
  - **`CSS utility framework`** - such as: `UnoCSS` or `Lightening CSS`(used in Tailwind)
   > toolkit, short codes, presets, functions, optimizing, speed, minifier)  
  - **`Headless/Structure`** (you do custom style): headless ui, Melt UI, Bits UI (Svelte)
  - **`Tailwind CSS`**: has pro/cons, yet from v3 (mostly 4) I confirm general use-case to be valid  
  - **`Minimal Libs`**: Melt UI(basics), Pico CSS(default styled), BeerCSS, DaisyUI(pure CSS lib)  
  - **`CSS toolkit`**:  Tailwind or UnoCSS - build available CSS presets/syntax into standard CSS  
  - **`UI-Kits`**: Daisy UI(CSS) .... `functional components`:  Skeleton, flowbite, ShadCN
  - **`Icon-sets`**: `unplugin-icons` : best way of using icons, no deps, vite plugin tooling
  - **`3D (WebGL/GPU)`**:  Spline, Babylone.js(FW), Three.js(lib), Threlte(Svelte+three), Unity Tiny  
  
  
 ### [UI Recommendations](#ui-recommendations--reason) + `reason`:
 - `UnoCSS`  - best toolkit and  presets. (code in other Lib, compiled into standard CSS)  
 - `picoCSS` - best for predefined styling of standard HTML Tags.  
 - `DaisyUI` - best CSS UI lib you can get where JS is optional (pre UI kit).  
 - `BeerCSS` - better option in case you're into material design concept.
 - `Shadcn`  - best customizable components kit (mostly in Shadcn-Svelte).
 - `Skeleton UI`- best UI components kit for Svelte framework.
 - `Agnostic UI`- various pros, in case it benefit your work.  

[_^_](#shortcuts-)  
<br>  

### [Cloud platforms](#cloud-platforms):  

- `Cloudflare`: most professional option, reliable, advanced network system and services.  
- `Hosting clouds`: used to host site/app, but now offer many cloud functions/solutions Ex: Vercel or Netlify  
- `Enterprise`: (more features+scale - extra cloud functions/services)  
> 1. Amazon AWS .... 2. Google/Firebase  .... 3. Azure (Microsoft)  

- #### [`Alternatives`](#alternatives): 
  - `Cloud`: Vercel, Supabase - `CMS`: Prismic, Builder.io
  - `Self-host`: [Cloud](): Coolify - [CMS](): Sveltia - [Server](): `PocketBase`  
  - `Decentralised` -> Nostr, Bluesky/AT protocol. Social features, free, secure, anti-censorship.  
  - `Self hosted`: PocketBase ... `Basic/Dapp` -> Gun.js => free, encrypted, distributed(web torrent).  
  - `Fullstack servers` + `default options`: cyclic.sh(full options +S3 +DynamoDB) - railway.app (+postgreSQL)

[_^_](#shortcuts-)  
<br>

### [Database](#database):
- `Next-Gen`: Nostr, AT protocol, GunDB - decentrlized, secure, extra features(DB+SN/COMM).  
- `Performance`: cloud edge DBs `->` Turso(libSQL), Cloudflare/DenoDeploy(KV). `multi-model`: Redis + modules.  
- `Innovative `: Drizzle + Turso - EdgeDB - SurrealDB - Dgraph (graphQL+DX) - Vector DBs (AI use-cases).  
- `Open Source`: `libSQL` (fastest SQL on edge), `Arango DB` (multi-model) both can self host or cloud.    
- `Recommendations`:  
  > **` Nostr`** : decentralized communication protocol. user ownership of data, privacy and sharing.  
  > **` Turso`** : libSQL DB on cloud/edge networks, libSQL is a fork of SQLite but both local, remote and server.  
  > **` Drizzle`**: the only ORM worth using, **`Reason`**: work with various DB formats without knowing them.  
  > **` EdgeDB`**: simple + you prefer EdgeQL + includes ORM/graphQL-ish model (no need for seperate ORM).  
  > **` SurrealDB`**: advanced, lots of DB models, features, customize and options.

[_^_](#shortcuts-)  
<br>  

### [API / Communication patterns](#api):

- `REST `... a client request data/information... from a server, which responds with state+data.  
- `GraphQL`. similar to rest but query a specific set of data, only effective if correctly queried(not less, not more).  
- `gRPC / tRPC` . binary data, prioritise performance, volume, and security. next generation of protobuffers.  
- `WebSocket` For real time, low latency applications.  
- `WebRTC / WebTorrent`  applications of distributed net, shared, p2p, serverless, save cost, user privacy/annonymity.  
- `ORM (DB interaction model)` custom SQL/nonSQL query access method. custom relational behavior, code to DB interfacing.  
<br>
  
### [Programming Languages](#programming-languages):  

#### Low level  
- **`Rust`**: WebASM std / Safe / Precise / System / Performance / Resources / Community.  
- **`Zig`** - **`Carbon`**: C++ alternatives - **`Julia`**: low-level Performance, high-level syntax.  
- **`Go`**: (Low/Med level): simple good syntax, well developed/maturity, good for backend.  
- **`Nim`**(+fast, semi python syntax). **`Mojo`**: (+python-like, resources, AI, Devs like it).  
    
#### High level
- **platform based**: `All: Web/JS`, `AI: Python, JS (APIs)`, `Mac/IOS: Swift`.  
- **other good langs**: `Elixir`, `Haskel`, `C++`, `C#`, `Bend`.  
- **`Bend`**: Parallel processing computation. Use CPU/GPU cores **WITHOUT** specific/low-level methods (Cuda, Metal...)
  
**(Type Safety / Typescript)**:
  - `Typescript`: Not a language, a superset over JS - a type system for JS - compiles to JS.  
  - `Valibot`: schema library for validating structural data. also on runtime and integration point.  
  - `...note`: type safety feature is effective for specific use-case and not universal usage.  <details> <summary>`...more on type safety and typescript`: </summary> Majority misunderstand TS for safety, security and a language by itself, while it mostly impacts development cycle. For product is only effective if is implemented at runtime and integration validation points. Therefore use Typescript/typesafety layer only when the usecase is valid, or required. such as immutable restricted and custom defined data structures. `Ex`: database schemas, configuration, authentication...  
`more usecases`: large teams - random/changing developers. different developers encounter type restrictions and potential issues/errors, they are forced to resolve type and other restrictions before merging or deliver to other devs. This ensures all follow same guidelines and patterns, getting defined results... yet codebase becomes more complex, takes time and cost. It's simpler and more efficient to use a validation system, such as `Valibot`, can use it in JS too, and in runtime.  
</details>
  
[_^_](#shortcuts-)  
<br>
  
### [Other stuff]()  
- **`Hosting`**: .. Vercel, Cloudflare Pages, Deno Deploy, Begin, Netlify.  
- **`Store/e-commerce`**: free open-source, best for developers: `Medusa` . best for non-devs: `Shopify`.  
- **`Static Site Generator`**:  Astro(all), Hugo(go), Hexo(js), Next(react), Nuxt(vue), MkDocs(py)  
- **`Content Management System`**:  Primo(svelte), Strapi, Ghost, Netlify CMS, Apostrophe, Factor(vue).
- **`Audio API`**: Tone.JS(free, all round audio API),  Twilio(Call communication, speech).  
- **`Dev/Repo` Platforms**: Github, Gitlab, Gitea (self-host), Stackblitz, Notion, Collab...  
- **`Dev tools`**:  CLI tools(GIT, bash, npm...), vite(bundler), vs-code + extensions, emmet...
- **`Kubernetes`**: Fault Taulerant application containers to manage scale, monitor, resources.  

[_^_](#shortcuts-)  
***
<br>  

  
## [Frameworks information](#frameworks-information)  
<br>  

### [Frameworks Architecture](#frameworks-architecture)  

- `Font-end`(client side) - `Backend`(server-side) - `Fullstack`(Front and back) - `Unified Fullstack`(integrated model).  
- **SSG** `Static Site Generation` pre-built app/content > host-CDN > page/app delivered on user request > on client side.  
- **CSR** `Client side rendering` both static and dynamic content on client side. Updates are based on app logic and UI design.  
- **SSR** `Server Side Rendering` UI > client > user interaction > server > processed real-time on server > new renders > client.  
- **Modern** `Custom Multi Model` SSG + SSR + custom optimizations, only changes updates/delivers. `+performance` `+efficiency`.  
- various features: `Reactivity` - `Signals` - `Runtime` - `Compiled` - `Snippets` - `defined structure` - `Event management`.  

### [Frontend](#frontend):  
 - **1. `Svelte`**: (Best overall), DX+, innovative, compiles to standard web, long term strategic choice.  
 - **2. `Solid`**: (Minimal) fast, efficient, reliable, fine tuned reactivity, react devs alternative.  
 - **3. `Vue`**: (community) __ `Angular` / `React` / `.Net` (GG/FB/MS company platforms), Job offers/forced/required.  
<br>  

### [Backend](#backend):

#### JavaScript Runtimes:  
  - **`Deno`**: secure by default, lighter, faster, Wasm, better concept, +DX. *(recommended)*  
  - **`Node`**: core JS Runtime most libs, support, popular. Node.JS BE frameworks: `hono`, `polka`, `koa`  
  - **`Bun`** : Node.js compatible but higher performance.  

#### Python eco-system:  jobs, popularity, AI libs/community, resources, ease of usage, +beginners.  

[_^_](#shortcuts-)  
<br>  

### [Fullstack](#fullstack): 
**`Sveltekit`**: complete yet custom scalable solution, flexible use of frontend + backend.  
> *Best web/app framework + DX, combined best practices and innovations in web ecosystem.*  
**`Phoenix`**: Live view generative FE + Elixir BE. Best for server oriented web development.
**`Astro`**: your frontend of choice + a unified good set of predefined patterns, tools, DB!
**`Custom Build`**: `Vite(bundler/dev-server)` + `Nitro(Server)` + `Vinxi(Router)` + `FE framework/tools`  

**`Node.js cloudish frameworks`**:  Next(Vercel/React), Nuxt(VUE), Astro(multi platform).  
<br>  

### [Svelte framework pros](#svelte-framework-pros):  
**`Developer Experience`**: write less code, concentrate on your ideas, not development complexity.  
**`Standard`**: the code is compiled to standard JS. Fast/optimized, can be used anywhere, reusable.  
**`Less complexity`**: easier to read code, compiled, no v-dom overhead, no framework caused issues at runtime.  
> less Testing/Dependency issues:  unexpected reactions, conflicts, misunderstanding source of issues.  
> less Errors: due to not having runtime dependencies, or external factors except your own code.  

**`Less Cost`**: easier to read code of other devs => continue their work + less bugs + less testing + faster development.  
**`Smaller bundle size`** (Compiled), without virtual-dom and framework overhead...  

[_^_](#shortcuts-)  
***
<br>  


# [Extra Information](#extra-information)  
<br>  

## **Web Development - about definitions**   
- `Front-end`: Dev/Design of client side web app/site, dev/Design. HTML5, CSS, JavaScript, PWA, frameworks, Web assembly...  
- `Back-end`: processing/data on server network, host/cloud, centralized or distributed. SSR(Server Side Rendering). 
- `DevOps`: manage and process dev/product ecosystem. analytics, control, automation on Local, remote, distributed systems  
- `Cloud`: online server platforms, you can subscribe to services: process, storage, resources, ready made functions.  
- `Cloud services`:  when you don't have a scalable server/resources. 2- require API/Apps/services from amazon, google,... 
- `Developer Experience`: (DX) satisfaction rate of developer, plus how empowering, practical, direct, and unambiguous it be.  
- `Correct development method` â‡’ simplify, reuse, secure, update, avoid complex dependencies/overhead.  
- `Software Engineering`:  use engineering principles and process-methods to approach the issue/task.  
- `Solution Architect`: a senior lead/engineer that evalutes an idea/goal/issue, then design, document and execute a structured plan while making many considerations.  
> A solution architect has some business insight/strategy and various technical knowledge/experience, using engineering principles, analytics,... design-pattern-process-methodology and some research experience.  

[_^_](#shortcuts-)  
***


## **[Web development guideline](web-development-guideline):**  
 **1. Learn the base web standards** -> (HTML, CSS, Javascript) follow/practice tutorials. Make few apps.(ex: Todo)  
 **2. New web standards** -> ES6/next, new HTML, new CSS (grid,...)  practice/try what you learn.  
 **3. Update the previous apps you made**, using new things you learned. make a game and a blog site.  
 **4. Deploy**: learn how to host/deploy your site.  Host on cloudflare pages, deno deploy, begin, netlify, github pages,...  
 **5. Learning decision**: learn extra stuff once is required(predict it). (Ex: DB, AI, specific tools/libs...)  
 **6. Learn a Framework**: better Dev-eXp & scoping. composable, reusable components, structure and configuration.  
 **7. Learn Design**: Patterns, tools, UI/UX(user interface/experience). Concepts: visual clarity, visual effects, utility 1st.  
 **8. Responsive design**: native looks, any device, clear focus, usability/accessibility. CSS flex, grid...  
 **9. Backend**: 1. Sveltekit(if using svelte) ___ 2. Deno: new js-runtime replacement for Node.js by its creator.  
 **10.Personal** various experiences, use GIT, github, Make a portfolio site (show case). a social profile: Linkedin + twitter.  
 **11.Testing/Typing**: only if neccessary and: in large teams on complex projects with security risk or much new/junior/outsourced devs.  
 **12.Summary**: Be an expert in one field, pro on few more, know about the rest. Fullstack: Frontend + Backend + Eco-system + Experience.  

[_^_](#shortcuts-)  


## **[About AI - Generations](about-ai---generations)**

`Past AI`: Machine Learning + Data/algorithms.  
Output results such as detection/decision/states... are made from a defined input processed by Machine Learning + Data science tools/patterns to extract meaningful data/states, using specific algorithms and models.  

`Pre/Current`: Generative AI, builds result from input data.  
- input can befrom single or multiple sources such as: files/DB/web/user prompt/system/parameters...  
- input/User describes a composed request: question/s, problem/s, statement prompt/s, data.  
- then Ai model process all to construct/expand/difuse/compose/conclude... Finally it generates the result based on request/objective.  

`Present`: Generative AGI. Is the same as above, but more accurate, matured and efficient.
- multi-modal, multi-tooling, larger models, improved data quality and training, higher performance hardware.  
- various methods and techniques used to improve results.
- increase precision/performance, reduce hallucination/mistakes, iterative pipelines to improve/abstract/clean/test data, verify, validate results.  

`Future Ai`: is a systemic AGI.  It creates custom composed advanced solutions, adding real-time autonomuos abilities.  
The past generation recognise, detect, compose a result, This new generation understands (input + general concept + you).  
- focused concepts and Results processed in realtime cycle, by a general purpose dynamic multi-model.  
- the output iterates/evolves based on all defined parameters, whatever interacts with it.  
- time-scalable, includes a history record, remember and relates, process past and current events, consider future.  
- optional autonomous act: triggers new events or impact external entities, based on various factors/parameters + input/sensor data.

[_^_](#shortcuts-)


 ### [Work Tips](#work-tips):
 - Better: learn best new tech options, practice, freelance, get hired, build an idea startup team.
 - Easier: take a positive internship, learn, collab, you either get hired or improve portfolio/experience.  
 - Collaborate: Learn/Use collaboration tools/platforms like GitHub.  
 - Job: find a job or startup a new team.  Wish you the best.  

*** 
<br>  

## [The Web - status summary](#the-web-status-summary)
The web was originally made to communicate with text and data, it later evolved to present simple graphics and images.  
<details> <summary>...press to expand. </summary>  
Hardware advancements in performance and capacity, plus emerging smartphones and social networks caused web based online services go mainstream in network communications, it progressed fast and competes with native platforms.  
The sudden progress pace in contrast with the concept of keeping it backward compatible with legacy standards, caused some complexity and confusion in the last decade due to workarounds to support new features by vendor prefixes, various 3rd party libs, tools and frameworks to achieve demands of dev/user/market. The slow adoption of new trends was caused by issues with backward compatibility of existing sites and old systems while native mobile and desktop platforms had all breaking changes at once to support new hardware. By then 3rd party libs, prefixes and frameworks... were made to solve/patch the issue and provide features that didn't exist in web standards yet.  

Good news, the new web standards and innovations, improved the situation, furthermore Frameworks evolved and matured including new Web APIs to provide functionality and access to new technologies. Therefore with much flexibility, compatibility and openness, Web eco-system can now compete with native desktop and mobile platforms.  

Whenever learning something, learn latest stable standards and best practices, some of the old prefixes, 3rd party libs,... are not required anymore...(as explained above) unless is justified, mandatory or no alternatives. The recommended trends mentioned here were handpicked by checking reviews comparison, personal experiments, and by looking into new trends top professionals adopt.  
</details>

[_^_](#shortcuts-)  
***
<br>  

### [New developer or decision maker?](#new-developer-or-decision-make?)
<details>
<summary> ...Details - Reasons and Pointers on choosing tech stack/methods... (press to expand)  
</summary>
- Avoid learning 6 ~ 10+ years old stuff if a better alternative is available.
 old tech was made for past era ecosystem, development model and HW/SW/issues.  

- Is still popular due to seniors who learned it in past when it was a valid option and using it at work for years, later new developers are forced to follow them. This process might repeat multiple times...   

- The old popular tech nature: ___ it works, is popular and has big community and resources, yet in time it becomes more complex, due to extensions, compatibility patches and conflict solving layers to make both the original and new syntax/tools/requirements work together...  Aside of that each time a new feature is added, this process might repeat, and the platform gets large, complex, multiple different revisions.(Ex: MS SDKs, .net framework,...)  

- Breaking changes and migration: ___ when a new feature that contradicts something in the system which can't be solved, the devs will decide to either give up on the feature, add extra flags/configs or make a breaking change, thus you must stay on old branch or learn + update your previous codes or totally migrate if is hopeless.  
  - Each time a breaking change shows up, you might need to repeat this process. this makes multiple dev branches in a company if the team can't / won't follow.  

- Prevent Issues:  an old legacy target which depends on layers of other legacy tech, will encounter conflicts, compatibility, deprecated dependencies, which will cost time + resources + man power to solve them. 

- Low level coding is not affected much by the mentioned issues. they rarely change, and if so, is about new features, compatibility and stability.  

- Unnessecary overhead: as old devs retire,  new ones might add extra layers of abstraction instead of updating the original code, these issues cause: extra complexity, overhead, extra cost in long-term, Large number/size of files, large developer teams, or slow working pace,...
</details>

[_^_](#shortcuts-)  
***
<br>  

`
import('md-page.js').then(module=> module(MD) );
 
</script>
<noscript>
